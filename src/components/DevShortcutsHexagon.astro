---
import { DEV_LINKS } from '@/consts'
import { Icon } from 'astro-icon/components'

// ------------- Hex math helpers (ported from react-hexgrid) -------------
type Point = { x: number; y: number }
type HexCoord = { q: number; r: number; s: number }
type Orientation = {
  f0: number
  f1: number
  f2: number
  f3: number
  b0: number
  b1: number
  b2: number
  b3: number
  startAngle: number
}
type LayoutDimension = {
  size: Point
  spacing: number
  origin: Point
  orientation: Orientation
}

const SQRT3 = Math.sqrt(3)
const ORIENTATION_FLAT: Orientation = {
  f0: 3 / 2,
  f1: 0,
  f2: SQRT3 / 2,
  f3: SQRT3,
  b0: 2 / 3,
  b1: 0,
  b2: -1 / 3,
  b3: SQRT3 / 3,
  startAngle: 0,
}

const BASE_HEX_SIZE = 104
const HEX_SIZE = 168
const BORDER_WIDTH = 24

const layout: LayoutDimension = {
  size: { x: HEX_SIZE, y: HEX_SIZE },
  spacing: 1,
  origin: { x: 0, y: 0 },
  orientation: ORIENTATION_FLAT,
}

const GRID_WIDTH = 5
const GRID_HEIGHT = 5

function calculatePolygonPoints(size: number, flat = false) {
  const angleOffset = flat ? 0 : Math.PI / 6
  const corners: Point[] = []
  for (let i = 0; i < 6; i++) {
    const angle = (2 * Math.PI * i) / 6 + angleOffset
    corners.push({
      x: size * Math.cos(angle),
      y: size * Math.sin(angle),
    })
  }

  return corners.map((corner) => `${corner.x.toFixed(2)},${corner.y.toFixed(2)}`).join(' ')
}

function coordKey(hex: HexCoord) {
  return `${hex.q},${hex.r},${hex.s}`
}

function hexToPixel(hex: HexCoord, layout: LayoutDimension): Point {
  const { orientation: M, size, spacing, origin } = layout
  let x = (M.f0 * hex.q + M.f1 * hex.r) * size.x
  let y = (M.f2 * hex.q + M.f3 * hex.r) * size.y
  x *= spacing
  y *= spacing
  return { x: x + origin.x, y: y + origin.y }
}

function rectangle(mapWidth: number, mapHeight: number): HexCoord[] {
  const cells: HexCoord[] = []
  for (let r = 0; r < mapHeight; r++) {
    const offset = Math.floor(r / 2)
    for (let q = -offset; q < mapWidth - offset; q++) {
      cells.push({ q, r, s: -q - r })
    }
  }
  return cells
}

function hexagon(mapRadius: number): HexCoord[] {
  const cells: HexCoord[] = []
  for (let q = -mapRadius; q <= mapRadius; q++) {
    const r1 = Math.max(-mapRadius, -q - mapRadius)
    const r2 = Math.min(mapRadius, -q + mapRadius)
    for (let r = r1; r <= r2; r++) {
      cells.push({ q, r, s: -q - r })
    }
  }
  return cells
}

// 根据cells的下标与对应值控制显示在哪些格子里
const ACTIVE_COORDS: HexCoord[] = [
  // { q: -1, r: 0, s: 1 },
  // { q: 0, r: 0, s: 0 },
  // { q: 1, r: 0, s: -1 },
  { q: 2, r: 0, s: -2 },
  { q: 3, r: 0, s: -3 },
  { q: 0, r: 1, s: -1 },
  { q: 1, r: 1, s: -2 },
  { q: 2, r: 1, s: -3 },
  { q: 0, r: 2, s: -2 },
  { q: 1, r: 2, s: -3 },
  { q: 2, r: 2, s: -4 },
  { q: 0, r: 3, s: -3 },
  { q: 1, r: 3, s: -4 },
  { q: 2, r: 3, s: -5 },
]

const gridCoords = rectangle(GRID_WIDTH, GRID_HEIGHT)
const gridKeyMap = new Map(gridCoords.map((hex) => [coordKey(hex), hex]))

const preferredCoords = ACTIVE_COORDS.map((hex) => gridKeyMap.get(coordKey(hex))).filter(
  Boolean,
) as HexCoord[]

const preferredKeySet = new Set(preferredCoords.map((hex) => coordKey(hex)))
const remainingGridCoords = gridCoords.filter((hex) => !preferredKeySet.has(coordKey(hex)))

let orderedActiveSlots = [...preferredCoords, ...remainingGridCoords]

if (DEV_LINKS.length > orderedActiveSlots.length) {
  const usedKeys = new Set(orderedActiveSlots.map((hex) => coordKey(hex)))
  let radius = Math.max(GRID_WIDTH, GRID_HEIGHT)

  while (orderedActiveSlots.length < DEV_LINKS.length) {
    radius += 1
    for (const hex of hexagon(radius)) {
      const key = coordKey(hex)
      if (usedKeys.has(key)) continue
      orderedActiveSlots.push(hex)
      usedKeys.add(key)
      if (orderedActiveSlots.length === DEV_LINKS.length) break
    }
  }
}

const assignedCoords = orderedActiveSlots.slice(0, DEV_LINKS.length)
const coordToLink = new Map<string, (typeof DEV_LINKS)[number]>()
assignedCoords.forEach((hex, index) => {
  const link = DEV_LINKS[index]
  if (!hex || !link) return
  coordToLink.set(coordKey(hex), link)
})

const renderCoordMap = new Map<string, HexCoord>()
gridCoords.forEach((hex) => renderCoordMap.set(coordKey(hex), hex))
assignedCoords.forEach((hex) => {
  if (!hex) return
  renderCoordMap.set(coordKey(hex), hex)
})

const renderCoords = Array.from(renderCoordMap.values())

const hexagonPoints = calculatePolygonPoints(layout.size.x, true)
// const circleRadius = layout.size.x * 0.84
const circleRadius = 80

const baseCells = renderCoords.map((hex) => ({
  hex,
  link: coordToLink.get(coordKey(hex)) ?? null,
  center: hexToPixel(hex, layout),
}))

const xs = baseCells.map((cell) => cell.center.x)
const ys = baseCells.map((cell) => cell.center.y)
const padding = layout.size.x * 0.45
const minX = Math.min(...xs) - padding
const maxX = Math.max(...xs) + padding
const minY = Math.min(...ys) - padding
const maxY = Math.max(...ys) + padding
const sizeScale = HEX_SIZE / BASE_HEX_SIZE
const rawWidth = maxX - minX
const rawHeight = maxY - minY
const centerX = (minX + maxX) / 2
const centerY = (minY + maxY) / 2
const viewWidth = rawWidth / sizeScale
const viewHeight = rawHeight / sizeScale
const viewMinX = centerX - viewWidth / 2
const viewMinY = centerY - viewHeight / 2
const viewBox = `${viewMinX} ${viewMinY} ${viewWidth} ${viewHeight}`
const iconClipId = 'hexIconClip'

const cells = baseCells.map((cell) => ({
  ...cell,
  showContent: Boolean(cell.link),
}))
---

<svg
  class="hex-grid hex-grid--polygons"
  width="100%"
  height="100%"
  viewBox={viewBox}
  xmlns="http://www.w3.org/2000/svg"
  preserveAspectRatio="xMidYMid slice"
>
  <g class="hex-grid__group">
    {cells.map(({ link, center }, index) => {
      const isGhost = !link
      return (
        <polygon
          class={`hexagon-bg ${isGhost ? 'hexagon-bg--ghost' : ''}`}
          points={hexagonPoints}
          fill="transparent"
          stroke="#252525"
          stroke-width={BORDER_WIDTH}
          transform={`translate(${center.x}, ${center.y})`}
          data-index={index}
        />
      )
    })}
  </g>
</svg>

<svg
  class="hex-grid hex-grid--icons"
  width="100%"
  height="100%"
  viewBox={viewBox}
  xmlns="http://www.w3.org/2000/svg"
  preserveAspectRatio="xMidYMid slice"
>
  <defs>
    <clipPath id={iconClipId} clipPathUnits="userSpaceOnUse">
      <circle cx="0" cy="0" r={circleRadius} />
    </clipPath>
  </defs>

  <g class="hex-grid__group">
    {cells.map(({ link, center, showContent }, index) => {
      if (!link || !showContent) return null
      return (
        <g
          class="hexagon-wrapper"
          transform={`translate(${center.x}, ${center.y})`}
          data-index={index}
        >
          <a
            href={link.href}
            target="_blank"
            rel="noopener noreferrer"
            aria-label={link.label}
          >
            <title>{link.title}</title>
            <g class="icon-group">
              <circle
                r={circleRadius}
                fill="hsl(var(--secondary))"
                fill-opacity="0.45"
                stroke="hsl(var(--border))"
                stroke-width={Math.max(4, BORDER_WIDTH * 0.32)}
                class="icon-circle z-10"
              />

              {link.icon.startsWith('mdi:') ? (
                <foreignObject
                  x={-(layout.size.x * 0.7)}
                  y={-(layout.size.y * 0.7)}
                  width={layout.size.x * 1.4}
                  height={layout.size.y * 1.4}
                  clip-path={`url(#${iconClipId})`}
                  class="icon-foreign"
                >
                  <div class="icon-container">
                    <Icon
                      name={link.icon}
                      class="hexagon-icon"
                      style="color: rgb(233, 211, 182);"
                      aria-hidden="true"
                    />
                  </div>
                </foreignObject>
              ) : (
                <image
                  href={link.icon}
                  x={-layout.size.x * 0.3}
                  y={-layout.size.y * 0.3}
                  width={layout.size.x * 0.6}
                  height={layout.size.y * 0.6}
                  clip-path={`url(#${iconClipId})`}
                  class="hexagon-image"
                />
              )}
            </g>
          </a>
        </g>
      )
    })}
  </g>
</svg>

<style>
  .hex-grid {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  .hex-grid--polygons {
    z-index: 1;
  }
  .hex-grid--icons {
    z-index: 20;
  }

  .hex-grid__group {
    transform-origin: center;
    transform: translateX(-114px) translateY(60px) scale(1.08);
  }

  .hexagon-wrapper {
    cursor: pointer;
    pointer-events: auto;
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  .hexagon-wrapper a {
    outline: none;
    -webkit-tap-highlight-color: transparent;
    pointer-events: auto;
    cursor: pointer;
  }

  .hexagon-wrapper a title {
    pointer-events: none;
  }

  .hexagon-bg,
  .icon-circle,
  .icon-group {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  .icon-circle {
    stroke-width: 4px;
    transform-origin: center;
    transform-box: fill-box;
  }
  .icon-group {
    transform-origin: center;
    transform-box: fill-box;
    filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.45));
  }

  .hexagon-wrapper:hover .icon-circle {
    fill-opacity: 0.85;
    stroke: hsl(var(--primary));
    stroke-width: 4px;
    transform: scale(1.08);
  }

  .hexagon-wrapper:hover .icon-group {
    transform: rotate(12deg);
    transform-origin: center;
  }

  .hexagon-bg--ghost {
    stroke-dasharray: none;
  }

  .icon-container {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    border-radius: 9999px;
  }

  .hexagon-icon {
    width: 100% !important;
    height: 100% !important;
    max-width: 88px;
    max-height: 88px;
  }

  .hexagon-image {
    object-fit: contain;
  }

  .icon-foreign {
    overflow: visible;
  }

  :global(.hexagon-icon) {
    color: rgb(233, 211, 182) !important;
  }
</style>
